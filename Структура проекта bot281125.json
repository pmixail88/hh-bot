{
    "project_name": "bot",
    "structure": {
        "core": {
            "__init__.py": "",
            "config.py": "# Configuration settings\nimport os\n\nclass Config:\n    BOT_TOKEN = os.getenv('BOT_TOKEN')\n    DATABASE_URL = os.getenv('DATABASE_URL')\n    DEBUG = os.getenv('DEBUG', False)",
            "dependencies.py": "# Dependency injections\nfrom typing import Dict, Any\n\nclass Dependencies:\n    def __init__(self):\n        self._services = {}\n    \n    def register(self, name: str, service: Any):\n        self._services[name] = service\n    \n    def get(self, name: str) -> Any:\n        return self._services.get(name)",
            "errors.py": "# Custom exceptions\nclass BotError(Exception):\n    \"\"\"Base exception for bot errors\"\"\"\n    pass\n\nclass DatabaseError(BotError):\n    \"\"\"Database related errors\"\"\"\n    pass\n\nclass ServiceError(BotError):\n    \"\"\"Service related errors\"\"\"\n    pass"
        },
        "database": {
            "__init__.py": "",
            "models.py": "# Database models\nfrom sqlalchemy import Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'users'\n    \n    id = Column(Integer, primary_key=True)\n    telegram_id = Column(Integer, unique=True)\n    username = Column(String)\n    created_at = Column(DateTime)",
            "repository.py": "# Database operations\nfrom sqlalchemy.orm import Session\nfrom . import models\n\nclass UserRepository:\n    def __init__(self, session: Session):\n        self.session = session\n    \n    def get_user_by_telegram_id(self, telegram_id: int):\n        return self.session.query(models.User).filter(\n            models.User.telegram_id == telegram_id\n        ).first()",
            "migrations": {
                "__init__.py": ""
            }
        },
        "handlers": {
            "__init__.py": "",
            "base.py": "# Base handler class\nfrom telegram.ext import ContextTypes\nfrom telegram import Update\n\nclass BaseHandler:\n    async def handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        raise NotImplementedError(\"Handler must implement handle method\")",
            "profile.py": "# Profile handlers\nfrom .base import BaseHandler\n\nclass ProfileHandler(BaseHandler):\n    async def handle(self, update, context):\n        await update.message.reply_text(\"Profile management\")",
            "search.py": "# Search handlers\nfrom .base import BaseHandler\n\nclass SearchHandler(BaseHandler):\n    async def handle(self, update, context):\n        await update.message.reply_text(\"Search functionality\")",
            "vacancies.py": "# Vacancy handlers\nfrom .base import BaseHandler\n\nclass VacancyHandler(BaseHandler):\n    async def handle(self, update, context):\n        await update.message.reply_text(\"Vacancy management\")",
            "llm.py": "# LLM handlers\nfrom .base import BaseHandler\n\nclass LLMHandler(BaseHandler):\n    async def handle(self, update, context):\n        await update.message.reply_text(\"LLM interactions\")"
        },
        "services": {
            "__init__.py": "",
            "hh_service.py": "# HH.ru API service\nimport aiohttp\nimport json\n\nclass HHService:\n    def __init__(self, api_key: str = None):\n        self.api_key = api_key\n        self.base_url = \"https://api.hh.ru\"\n    \n    async def search_vacancies(self, query: str):\n        \"\"\"Search vacancies on HH.ru\"\"\"\n        async with aiohttp.ClientSession() as session:\n            async with session.get(f\"{self.base_url}/vacancies\", params={\"text\": query}) as response:\n                return await response.json()",
            "llm_service.py": "# LLM service integration\nimport openai\nfrom core.config import Config\n\nclass LLMService:\n    def __init__(self):\n        self.client = openai.OpenAI(api_key=Config.OPENAI_API_KEY)\n    \n    async def generate_response(self, prompt: str):\n        \"\"\"Generate response using LLM\"\"\"\n        response = self.client.chat.completions.create(\n            model=\"gpt-3.5-turbo\",\n            messages=[{\"role\": \"user\", \"content\": prompt}]\n        )\n        return response.choices[0].message.content",
            "vacancy_service.py": "# Vacancy processing service\nfrom .hh_service import HHService\n\nclass VacancyService:\n    def __init__(self):\n        self.hh_service = HHService()\n    \n    async def process_vacancies(self, query: str):\n        \"\"\"Process and filter vacancies\"\"\"\n        vacancies = await self.hh_service.search_vacancies(query)\n        return self._filter_relevant_vacancies(vacancies)\n    \n    def _filter_relevant_vacancies(self, vacancies):\n        \"\"\"Filter vacancies based on criteria\"\"\"\n        return vacancies[:10]  # Return top 10",
            "cache.py": "# Caching service\nimport redis\nimport json\nfrom datetime import timedelta\n\nclass CacheService:\n    def __init__(self):\n        self.redis = redis.Redis(host='localhost', port=6379, db=0)\n    \n    def set(self, key: str, value, ttl: int = 3600):\n        \"\"\"Set cache value\"\"\"\n        self.redis.setex(key, ttl, json.dumps(value))\n    \n    def get(self, key: str):\n        \"\"\"Get cache value\"\"\"\n        value = self.redis.get(key)\n        return json.loads(value) if value else None"
        },
        "utils": {
            "__init__.py": "",
            "keyboards.py": "# Telegram keyboards\nfrom telegram import ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton\n\ndef main_menu_keyboard():\n    \"\"\"Main menu keyboard\"\"\"\n    return ReplyKeyboardMarkup([\n        [\"üîç –ü–æ–∏—Å–∫ –≤–∞–∫–∞–Ω—Å–∏–π\", \"üë§ –ü—Ä–æ—Ñ–∏–ª—å\"],\n        [\"üíº –ú–æ–∏ –≤–∞–∫–∞–Ω—Å–∏–∏\", \"ü§ñ AI –ü–æ–º–æ—â–Ω–∏–∫\"]\n    ], resize_keyboard=True)\n\ndef vacancy_actions_keyboard():\n    \"\"\"Vacancy actions inline keyboard\"\"\"\n    return InlineKeyboardMarkup([\n        [InlineKeyboardButton(\"üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å\", callback_data=\"save_vacancy\")],\n        [InlineKeyboardButton(\"üì§ –ü–æ–¥–µ–ª–∏—Ç—å—Å—è\", callback_data=\"share_vacancy\")]\n    ])",
            "states.py": "# Conversation states\nfrom telegram.ext import ConversationHandler\n\nclass UserState:\n    SEARCH = 1\n    PROFILE_EDIT = 2\n    VACANCY_DETAILS = 3\n    LLM_CHAT = 4\n\n# Conversation endpoints\nEND = ConversationHandler.END",
            "validators.py": "# Input validators\nimport re\n\ndef validate_email(email: str) -> bool:\n    \"\"\"Validate email format\"\"\"\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    return bool(re.match(pattern, email))\n\ndef validate_phone(phone: str) -> bool:\n    \"\"\"Validate phone number\"\"\"\n    pattern = r'^[+]?[\\d\\s\\-\\(\\)]{10,}$'\n    return bool(re.match(pattern, phone))\n\ndef validate_salary(salary: str) -> bool:\n    \"\"\"Validate salary input\"\"\"\n    return salary.isdigit() and int(salary) > 0",
            "scheduler.py": "# Background tasks scheduler\nimport asyncio\nimport schedule\nimport time\nfrom threading import Thread\n\nclass Scheduler:\n    def __init__(self):\n        self.running = False\n        self.thread = None\n    \n    def start(self):\n        \"\"\"Start scheduler in background thread\"\"\"\n        self.running = True\n        self.thread = Thread(target=self._run_scheduler)\n        self.thread.start()\n    \n    def stop(self):\n        \"\"\"Stop scheduler\"\"\"\n        self.running = False\n    \n    def _run_scheduler(self):\n        \"\"\"Run scheduler loop\"\"\"\n        while self.running:\n            schedule.run_pending()\n            time.sleep(1)\n    \n    def add_daily_task(self, time_str: str, task):\n        \"\"\"Add daily task\"\"\"\n        schedule.every().day.at(time_str).do(task)"
        },
        "middleware": {
            "__init__.py": "",
            "error_handler.py": "# Error handling middleware\nimport logging\nfrom telegram import Update\nfrom telegram.ext import ContextTypes\nfrom core.errors import BotError\n\nlogger = logging.getLogger(__name__)\n\nasync def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):\n    \"\"\"Global error handler\"\"\"\n    logger.error(f\"Exception while handling update: {context.error}\")\n    \n    if isinstance(context.error, BotError):\n        await update.message.reply_text(f\"‚ùå –û—à–∏–±–∫–∞: {context.error}\")\n    else:\n        await update.message.reply_text(\"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞\")\n\nasync def user_activity_middleware(update: Update, context: ContextTypes.DEFAULT_TYPE, next_handler):\n    \"\"\"Track user activity\"\"\"\n    user_id = update.effective_user.id\n    logger.info(f\"User {user_id} activated: {update.update_id}\")\n    return await next_handler(update, context)"
        },
        "main.py": "# Main bot file\nimport logging\nfrom telegram.ext import Application, CommandHandler, MessageHandler, filters\nfrom core.config import Config\nfrom handlers import profile, search, vacancies, llm\nfrom middleware.error_handler import error_handler\n\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=logging.INFO\n)\n\ndef main():\n    \"\"\"Start the bot\"\"\"\n    application = Application.builder().token(Config.BOT_TOKEN).build()\n    \n    # Add handlers\n    application.add_handler(CommandHandler(\"start\", profile.ProfileHandler().handle))\n    application.add_handler(CommandHandler(\"search\", search.SearchHandler().handle))\n    application.add_handler(CommandHandler(\"vacancies\", vacancies.VacancyHandler().handle))\n    application.add_handler(CommandHandler(\"ai\", llm.LLMHandler().handle))\n    \n    # Add error handler\n    application.add_error_handler(error_handler)\n    \n    # Start bot\n    print(\"ü§ñ Bot is starting...\")\n    application.run_polling()\n\nif __name__ == \"__main__\":\n    main()",
        "requirements.txt": "python-telegram-bot==20.7\nsqlalchemy==2.0.23\nalembic==1.12.1\nredis==5.0.1\nopenai==1.3.7\naiohttp==3.9.1\nschedule==1.2.0\npython-dotenv==1.0.0",
        ".env.example": "BOT_TOKEN=your_bot_token_here\nDATABASE_URL=sqlite:///bot.db\nOPENAI_API_KEY=your_openai_key_here\nREDIS_URL=redis://localhost:6379\nDEBUG=True",
        "README.md": "# Telegram Bot for Job Search\n\nA sophisticated Telegram bot for job search with AI assistance.\n\n## Features\n\n- üîç Smart vacancy search\n- ü§ñ AI-powered assistance\n- üíº Vacancy management\n- üë§ User profiles\n- üìä Analytics and caching\n\n## Setup\n\n1. Copy `.env.example` to `.env` and configure\n2. Install dependencies: `pip install -r requirements.txt`\n3. Run the bot: `python main.py`\n\n## Structure\n\n- `core/` - Core configuration and dependencies\n- `database/` - Database models and migrations\n- `handlers/` - Telegram message handlers\n- `services/` - External services integration\n- `utils/` - Utilities and helpers\n- `middleware/` - Middleware and error handling"
    }
}